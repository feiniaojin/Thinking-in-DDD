import{_ as e,c as t,o as a,a as i}from"./app.0703c3d1.js";const m=JSON.parse('{"title":"跨聚合事务处理","description":"","frontmatter":{},"headers":[{"level":2,"title":"1. 本地消息表","slug":"_1-本地消息表","link":"#_1-本地消息表","children":[]},{"level":2,"title":"2. TCC 事务模型","slug":"_2-tcc-事务模型","link":"#_2-tcc-事务模型","children":[]}],"relativePath":"8/ConsistencyBetweenAggregate.md"}'),n={name:"8/ConsistencyBetweenAggregate.md"},r=i('<h1 id="跨聚合事务处理" tabindex="-1">跨聚合事务处理 <a class="header-anchor" href="#跨聚合事务处理" aria-hidden="true">#</a></h1><p>聚合有一个原则：每一个事务只能更新一个聚合。因此，我们不应在同一个事务中同时更新两个聚合。</p><p>在聚合内部，我们可以使用事务来保证数据的一致性和完整性。但是，在跨聚合的场景下，事务处理就变得更加复杂。</p><p>目前许多应用依赖的数据库都实现了分库分表，两个聚合不一定在同一个数据库上，无法在保证同一个数据库事务中。</p><p>由于支持两阶段提交（2PC）的分布式事务的代价很大，因此我们要考虑其他的解决方案。</p><h2 id="_1-本地消息表" tabindex="-1">1. 本地消息表 <a class="header-anchor" href="#_1-本地消息表" aria-hidden="true">#</a></h2><p>在<a href="./../6/DomainEvent3.html">领域事件 3</a>中我们实现了领域事件存储，可以保证领域事件在本地事务中被提交，同时我们也学习了“采用事务日志拖尾发布领域事件”的方法。</p><p>因此，我们只需要订阅我们感兴趣的限界上下文发布到消息中间件的领域事件，根据领域事件更新本地的聚合根，即可保证跨聚合之间的事务一致性。</p><h2 id="_2-tcc-事务模型" tabindex="-1">2. TCC 事务模型 <a class="header-anchor" href="#_2-tcc-事务模型" aria-hidden="true">#</a></h2><p>针对实时性比较高，并且需要强校验的场景，我们可以通过创建领域服务（Domain Service）去实现 TCC 事务模型，完成跨聚合的事务处理。</p><hr><div><img src="https://s1.ax1x.com/2023/04/15/p9p2mKP.jpg"></div><p>欢迎加入作者的知识星球，您将获得：</p><ul><li>作者答疑</li><li>配套源码以及多个完整的DDD项目源码，包括权限系统、电商系统、校招平台、直播平台等</li><li>抢先阅读即将推出的《架构方法论》、《悟道项目管理》、《悟道团队管理》、《悟道产品经理》</li></ul>',14),c=[r];function s(_,l,d,o,p,h){return a(),t("div",null,c)}const u=e(n,[["render",s]]);export{m as __pageData,u as default};
