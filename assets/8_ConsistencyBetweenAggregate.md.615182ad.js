import{_ as e,c as t,o as a,a as i}from"./app.5efbbeb1.js";const g=JSON.parse('{"title":"跨聚合事务处理","description":"","frontmatter":{},"headers":[{"level":2,"title":"1. 本地消息表","slug":"_1-本地消息表","link":"#_1-本地消息表","children":[]},{"level":2,"title":"2. TCC 事务模型","slug":"_2-tcc-事务模型","link":"#_2-tcc-事务模型","children":[]}],"relativePath":"8/ConsistencyBetweenAggregate.md"}'),n={name:"8/ConsistencyBetweenAggregate.md"},r=i('<h1 id="跨聚合事务处理" tabindex="-1">跨聚合事务处理 <a class="header-anchor" href="#跨聚合事务处理" aria-hidden="true">#</a></h1><p>聚合有一个特性：每一个事务只能更新一个聚合。因此，我们不应在同一个事务中同时更新两个聚合。</p><p>目前许多应用依赖的数据库都实现了分库分表，两个聚合不一定在同一个数据库上，无法在保证同一个数据库事务中。</p><p>由于支持两阶段提交（2PC）的分布式事务的代价很大，因此我们要考虑其他的解决方案。</p><h2 id="_1-本地消息表" tabindex="-1">1. 本地消息表 <a class="header-anchor" href="#_1-本地消息表" aria-hidden="true">#</a></h2><p>在<a href="./../6/DomainEvent3.html">领域事件 3</a>中我们实现了领域事件存储，可以保证领域事件在本地事务中被提交，同时我们也学习了“采用事务日志拖尾发布领域事件”的方法。</p><p>因此，我们只需要订阅我们感兴趣的限界上下文发布到消息中间件的领域事件，根据领域事件更新本地的聚合根，即可保证跨聚合之间的事务一致性。</p><h2 id="_2-tcc-事务模型" tabindex="-1">2. TCC 事务模型 <a class="header-anchor" href="#_2-tcc-事务模型" aria-hidden="true">#</a></h2><p>针对实时性比较高，并且需要强校验的场景，我们可以通过创建领域服务（Domain Service）去实现 TCC 事务模型，完成跨聚合的事务处理。</p><hr><p>欢迎加入本书作者的知识星球，在星球中您将获得：</p><ul><li>本书作者答疑，无论是DDD学习过程中的问题，还是对现有项目进行DDD重构，都可以找作者唠唠</li><li>获得本书配套源码以及多套完整的DDD项目实战源码，包括权限系统、电商系统、校招平台、直播平台等项目</li><li>DDD属于开发中的高阶知识，历来掌握者寥寥，研究DDD的同行职级都不低，这里是拓宽人脉的好地方</li><li>与即将推出的《TOGAF架构方法论》、《悟道项目管理》、《悟道团队管理》、《悟道产品经理》等书共用一个星球，一次加入即可同时可获得其他知识专题的答疑</li></ul><div><img src="https://s1.ax1x.com/2023/04/15/p9p2mKP.jpg"></div>',13),c=[r];function s(_,l,d,o,h,p){return a(),t("div",null,c)}const m=e(n,[["render",s]]);export{g as __pageData,m as default};
