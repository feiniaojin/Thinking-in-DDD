import{_ as D,c as e,o as d,a}from"./app.f4c18165.js";const u=JSON.parse('{"title":"1.3 领域驱动设计落地答疑","description":"","frontmatter":{},"headers":[{"level":2,"title":"1.3.1 DDD适用范围","slug":"_1-3-1-ddd适用范围","link":"#_1-3-1-ddd适用范围","children":[]},{"level":2,"title":"1.3.2 贫血模型与充血模型的选择","slug":"_1-3-2-贫血模型与充血模型的选择","link":"#_1-3-2-贫血模型与充血模型的选择","children":[]},{"level":2,"title":"1.3.3 DDD落地的认知差异","slug":"_1-3-3-ddd落地的认知差异","link":"#_1-3-3-ddd落地的认知差异","children":[]},{"level":2,"title":"1.3.4 落地DDD要选什么技术框架、要用什么架构","slug":"_1-3-4-落地ddd要选什么技术框架、要用什么架构","link":"#_1-3-4-落地ddd要选什么技术框架、要用什么架构","children":[]}],"relativePath":"1/1.3.md"}'),i={name:"1/1.3.md"},p=a('<h1 id="_1-3-领域驱动设计落地答疑" tabindex="-1">1.3 领域驱动设计落地答疑 <a class="header-anchor" href="#_1-3-领域驱动设计落地答疑" aria-hidden="true">#</a></h1><h2 id="_1-3-1-ddd适用范围" tabindex="-1">1.3.1 DDD适用范围 <a class="header-anchor" href="#_1-3-1-ddd适用范围" aria-hidden="true">#</a></h2><p>都说简单的系统不适合DDD，复杂的系统才适合DDD，那如何评价系统适不适合实施DDD呢，有什么量化的标准吗？</p><p>如果一套理论，在简单的场景实践表现不好，但是在复杂的场景实践比较很好，那么这套理论真的在复杂场景能表现好吗？我认为是不能的，1+1都算不明白，四则混合运算我觉得肯定也是算不好的，复杂系统拆分之后也是由很多简单的子系统构成的。</p><p>业界之所以有“简单的系统不适合DDD，复杂的系统才适合DDD”的这么一个论调，完全不是因为DDD在简单的系统没办法实践，更多的是成本的考量。</p><p>主要有几方面成本：</p><ul><li>首先是学习成本，大部分团队成员缺乏DDD实战经验，需要花大力气进行培训宣导；</li><li>其次是时间成本，一方面DDD倡导一个事务一次只更新一个聚合，为了保证跨聚合更新的一致性，需要进行大量的研发工时投入以解决技术细节，很有可能给项目正常交付造成风险，一方面在实践过程中缺乏提效工具；</li><li>最后，我们构建简单的系统时，往往是处在战略落地的初级阶段，团队整体缺乏领域专业知识，给领域驱动设计带来实践障碍。</li></ul><p>事实上，在业务落地的初期，我非常推荐采用事务脚本的方式进行面向数据的编程。事务脚本给了我们一次更新多个聚合的能力，使得我们开发非常快捷粗暴。技术本身很难产生价值，技术往往需要通过业务载体产生价值，我们尽快把产品落地交付了，能让公司快速进行商业模式试错。</p><p>《实现领域驱动》这本书的第1章，介绍了一种DDD计分卡的方式，得分在7分以上，就推荐考虑实施DDD。这种打分的方式有一定的依据，但是实际上我会通过更简单快捷的方式去判断我们是否适合实施DDD。</p><p>我的判断方式是这样的：如果目标系统无法在一个数据库事务里进行跨聚合更新，那么就直接DDD。DDD要求一次数据库事务只能更新一个聚合，聚合之间要通过最终一致性保持一致。当我们分库分表、某个业务服务切分到外部团队单独数据库存储时，我们没有办法保证在一个数据库事务里完成跨聚合的变更，那么就应该果断进行DDD。</p><p>如果一开始就要分库分表，那一开始就实施DDD。</p><h2 id="_1-3-2-贫血模型与充血模型的选择" tabindex="-1">1.3.2 贫血模型与充血模型的选择 <a class="header-anchor" href="#_1-3-2-贫血模型与充血模型的选择" aria-hidden="true">#</a></h2><p>DDD落地永远绕不开贫血模型和充血模型的争议。</p><p>贫血模型指的是模型中只有属性没有行为。</p><p>充血模型则是指模型中既有属性也有行为。</p><p>对象的属性，即对象的内部状态；对象的行为，即对象具备的能力，也就是业务逻辑。</p><p>大部分Java程序员习惯了使用贫血模型，先通过ORM框架从数据库查询数据，然后Service操作这些数据对象完成业务逻辑，然后对数据库做更新。原本Service只需要给模型一个执行环境，现在需要又当爹又当妈把所有业务逻辑实现了再把结果set回去，稍微遗漏了业务逻辑的约束，就会造成问题。</p><p>DDD要求充血模型的原因，在于代表模型的行为也是模型的一部分。贫血模型只是提供了属性数据的容器，然后向Service公开了这些属性，操作这些属性数据的职责转嫁给了Service，这会导致Service所有的方法都必须充分了解模型的领域知识，面向对象三大特征之一的封装性荡然无存。</p><p>我们经常看到某个业务校验的逻辑在每个Service方法里面都出现一次，就是贫血模型泄漏了领域知识造成的。</p><p>关于贫血模型和充血模型的选择，我们将在<a href="./../2/2.2.html">2.2 贫血模型和充血模型</a>中进行详细论证。</p><h2 id="_1-3-3-ddd落地的认知差异" tabindex="-1">1.3.3 DDD落地的认知差异 <a class="header-anchor" href="#_1-3-3-ddd落地的认知差异" aria-hidden="true">#</a></h2><p>业界对于DDD的落地，主要有这么几种观点：</p><p>第一种，DDD只有战略设计的落地。持这个观点的，是一些懂一点技术的技术管理层（完全不懂技术的管理层已经被忽悠造轮子去了）。DDD战略设计的落地无疑是非常有价值的，起码在大方向上完成了子域划分，但却并没有办法产出高质量的代码。造成这个观点的原因，是因为DDD落地没有很好的案例、规范、配套研发提效工具，这也是笔者目前正在致力的方向：给案例、出规范、写工具。</p><p>第二种，只关注DDD部分战术落地。持这个观点的，大部分是一些DDD萌新朋友，由于对DDD理解的深度不够，经常纠结要选什么架构，经常纠结这个类、这个逻辑放哪里合适，束手束脚，举步维艰，最后直接躺平放弃。</p><h2 id="_1-3-4-落地ddd要选什么技术框架、要用什么架构" tabindex="-1">1.3.4 落地DDD要选什么技术框架、要用什么架构 <a class="header-anchor" href="#_1-3-4-落地ddd要选什么技术框架、要用什么架构" aria-hidden="true">#</a></h2><p>DDD与技术框架无关，用什么技术框架、用什么语言都不影响DDD的落地。</p><p>DDD常见的架构有很多：经典四层架构、六边形架构、整洁架构等等，很多刚接触DDD的朋友光是选择架构就挑花了眼。</p><p>实际上，我们并不需要有选择困难症，跟应用系统的本质最贴合的，就是最好的架构，后续会专门针对这个去分析。</p>',28),r=[p];function t(_,l,h,n,c,s){return d(),e("div",null,r)}const f=D(i,[["render",t]]);export{u as __pageData,f as default};
