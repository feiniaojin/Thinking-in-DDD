import{_ as s,c as a,o as n,a as l}from"./app.d9f712a7.js";const C=JSON.parse('{"title":"Factory","description":"","frontmatter":{},"headers":[{"level":2,"title":"1. Factory 的定义","slug":"_1-factory-的定义","link":"#_1-factory-的定义","children":[]},{"level":2,"title":"2. Factory 的实践","slug":"_2-factory-的实践","link":"#_2-factory-的实践","children":[]},{"level":2,"title":"3. 不使用 Repository 创建的原因","slug":"_3-不使用-repository-创建的原因","link":"#_3-不使用-repository-创建的原因","children":[]}],"relativePath":"4/Factory.md"}'),o={name:"4/Factory.md"},p=l(`<h1 id="factory" tabindex="-1">Factory <a class="header-anchor" href="#factory" aria-hidden="true">#</a></h1><h2 id="_1-factory-的定义" tabindex="-1">1. Factory 的定义 <a class="header-anchor" href="#_1-factory-的定义" aria-hidden="true">#</a></h2><p>Factory 是设计模式的一种，用来完成对象的创建。在领域驱动设计中，对于复杂的领域对象，不管是实体还是值对象，我们都可以使用 Factory 进行创建。</p><p>使用 Factory 的原因，是领域对象的创建过程太复杂，我们希望将领域对象的创建过程交由统一的对象进行管理，避免过多关注其创建过程。</p><h2 id="_2-factory-的实践" tabindex="-1">2. Factory 的实践 <a class="header-anchor" href="#_2-factory-的实践" aria-hidden="true">#</a></h2><p>对于实体来说，往往需要在创建时指定唯一主键，因此 Factory 可以交由 IOC 容器进行实例化管理，在创建的过程中注入某些依赖对象。</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Component</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">EntityFactory</span><span style="color:#89DDFF;">{</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    /**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">    * id生成器</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">     */</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">@</span><span style="color:#C792EA;">Resource</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">IdGenerator</span><span style="color:#A6ACCD;"> idGenerator</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Entity</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">newInstance</span><span style="color:#89DDFF;">(){</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#C792EA;">Entity</span><span style="color:#A6ACCD;"> entity </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Entity</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">        entity</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">setEntityId</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;font-style:italic;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">EntityId</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">idGenerator</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">newId</span><span style="color:#89DDFF;">()));</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">//TODO 其他初始化过程</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> entity</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>对于值对象来说，可以直接使用静态的方法完成创建。</p><h2 id="_3-不使用-repository-创建的原因" tabindex="-1">3. 不使用 Repository 创建的原因 <a class="header-anchor" href="#_3-不使用-repository-创建的原因" aria-hidden="true">#</a></h2><p>Repository 是面向聚合根的，更多的是作为仓储来保存或者加载聚合根。如果也由 Repository 进行领域对象创建，那么 Repository 就承担了过多的职责。</p><p>可能一些普通的实体、值对象也比较复杂，也需要封装创建过程，如果由 Repository 进行创建，这个时候就与“只有聚合根才拥有 Repository”产生了矛盾，因此，我们将单独使用 Factory 完成领域对象的创建。</p><p>要注意 Repository 加载聚合根和 Factory 创建实体两者过程的区别：Repository 是已经存在了聚合根，只是将其从持久化的数据库（或者其他持久化存储）加载到内存中，并将其重新组装为聚合根；Factory 是从无到有创建领域对象的过程。虽然两者在创建过程中可能都会先创建空对象，然后进行属性的 set，但是两者的语意并不相同。</p><hr><div><img src="https://s1.ax1x.com/2023/04/15/p9p2mKP.jpg"></div><p>欢迎加入本书作者的知识星球，在星球中您将获得：</p><ul><li>本书作者答疑，无论是DDD学习过程中的问题，还是对现有项目进行DDD重构，都可以找作者唠唠</li><li>获得本书配套源码以及多套完整的DDD项目实战源码，包括权限系统、电商系统、校招平台、直播平台等项目</li><li>DDD属于开发中的高阶知识，历来掌握者寥寥，研究DDD的同行职级都不低，这里是拓宽人脉的好地方</li><li>与即将推出的《TOGAF架构方法论》、《悟道项目管理》、《悟道团队管理》、《悟道产品经理》等书共用一个星球，一次加入即可同时可获得其他知识专题的答疑</li></ul>`,16),t=[p];function e(r,c,i,y,D,F){return n(),a("div",null,t)}const d=s(o,[["render",e]]);export{C as __pageData,d as default};
