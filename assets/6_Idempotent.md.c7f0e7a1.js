import{_ as s,c as a,o as n,a as l}from"./app.1a8c41e3.js";const F=JSON.parse('{"title":"幂等设计","description":"","frontmatter":{},"headers":[{"level":2,"title":"1. 幂等的定义","slug":"_1-幂等的定义","link":"#_1-幂等的定义","children":[]},{"level":2,"title":"2.如何实现幂等","slug":"_2-如何实现幂等","link":"#_2-如何实现幂等","children":[{"level":3,"title":"2.1 数据库级别","slug":"_2-1-数据库级别","link":"#_2-1-数据库级别","children":[]},{"level":3,"title":"2.2 状态机","slug":"_2-2-状态机","link":"#_2-2-状态机","children":[]},{"level":3,"title":"2.3 token 机制","slug":"_2-3-token-机制","link":"#_2-3-token-机制","children":[]}]}],"relativePath":"6/Idempotent.md"}'),p={name:"6/Idempotent.md"},e=l(`<h1 id="幂等设计" tabindex="-1">幂等设计 <a class="header-anchor" href="#幂等设计" aria-hidden="true">#</a></h1><h2 id="_1-幂等的定义" tabindex="-1">1. 幂等的定义 <a class="header-anchor" href="#_1-幂等的定义" aria-hidden="true">#</a></h2><p>幂等就是进行多次重复操作的结果和只进行一次操作的结果相同。</p><p>读请求不会导致数据的变更，因此读请求天然是幂等的。</p><p>写请求会导致数据状态的变更，因此需要考虑其幂等性：</p><p>写请求最后都可归纳到 SQL 的 insert/update/delete 这几个操作，在不做额外处理的情况下，它们的幂等性如下：</p><ul><li>insert：如果没有唯一性约束，每次 insert 时都使用数据库的自增主键，那么每次都新增新的记录，则不是幂等的</li></ul><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">-- 非幂等，每执行一次会新增一条记录</span></span>
<span class="line"><span style="color:#F78C6C;">insert into</span><span style="color:#A6ACCD;"> t(count) </span><span style="color:#F78C6C;">values</span><span style="color:#A6ACCD;"> (</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">-- id为唯一主键，则不管执行多次，最终都只会有一条id=1的记录，因而是幂等的</span></span>
<span class="line"><span style="color:#F78C6C;">insert into</span><span style="color:#A6ACCD;"> t(id,count) </span><span style="color:#F78C6C;">values</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">,</span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">);</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><ul><li>update：不依赖历史状态的update操作是幂等的，如果需要依赖历史状态进行计算，则不是幂等的。</li></ul><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-palenight"><code><span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">-- 幂等操作，直接设置结果，不管设置几次，count都是1</span></span>
<span class="line"><span style="color:#F78C6C;">update</span><span style="color:#A6ACCD;"> t </span><span style="color:#F78C6C;">set</span><span style="color:#A6ACCD;"> count</span><span style="color:#89DDFF;">=</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">where</span><span style="color:#A6ACCD;"> id</span><span style="color:#89DDFF;">=</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">-- 非幂等操作，最终count的值跟执行次数有关</span></span>
<span class="line"><span style="color:#F78C6C;">update</span><span style="color:#A6ACCD;"> t </span><span style="color:#F78C6C;">set</span><span style="color:#A6ACCD;"> count</span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">+</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">where</span><span style="color:#A6ACCD;"> id </span><span style="color:#89DDFF;">=</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><ul><li>delete：幂等操作，执行一次和执行多次的结果是一样的</li></ul><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-palenight"><code><span class="line"></span>
<span class="line"><span style="color:#F78C6C;">delete</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">from</span><span style="color:#A6ACCD;"> t </span><span style="color:#F78C6C;">where</span><span style="color:#A6ACCD;"> id </span><span style="color:#89DDFF;">=</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>之所以在领域事件之前先讲解幂等设计，是因为消费领域事件时，有可能因为多种原因需要进行重试，如果重试的逻辑不是幂等的，往往会导致错误的结果，比如多次扣款造成资损。</p><h2 id="_2-如何实现幂等" tabindex="-1">2.如何实现幂等 <a class="header-anchor" href="#_2-如何实现幂等" aria-hidden="true">#</a></h2><h3 id="_2-1-数据库级别" tabindex="-1">2.1 数据库级别 <a class="header-anchor" href="#_2-1-数据库级别" aria-hidden="true">#</a></h3><p>要求调用方在必须发起操作请求时必须携带RuequestId，服务端将每个请求落库保存到操作流水表中，并且在RuequestId对应的列上增加唯一索引。这样同一个RuequestId的操作请求由于数据库唯一键冲突无法落库保存，同时Java代码中会产生异常，捕获异常后直接返回重复执行提示或者丢弃消息，以此确保幂等性。</p><p>数据库级别的幂等控制虽然看起来比较重量级，但是可以作为最终的兜底方案，在唯一索引之前可以在代码中引入其他的幂等确认逻辑，减少写库。</p><p>对于重要的资金交易场景，一般都会有操作流水表作为兜底。</p><h3 id="_2-2-状态机" tabindex="-1">2.2 状态机 <a class="header-anchor" href="#_2-2-状态机" aria-hidden="true">#</a></h3><p>对于有限状态机类型的数据，如果状态机已经处于某一个状态，这时候收到上一个状态下的变更请求，我们就可以直接拒绝处理并返回提示。</p><p>例如账号的激活状态就是一个简单的状态机，可以简单的包括未激活、已激活、已失效这几种状态。</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-palenight"><code><span class="line"></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">enum</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ActiveState</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    Awaiting_Activation</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">待激活</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">),</span></span>
<span class="line"><span style="color:#A6ACCD;">    Activated</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">已激活</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">),</span></span>
<span class="line"><span style="color:#A6ACCD;">    Expired</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">已失效</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">Integer</span><span style="color:#A6ACCD;"> code</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">private</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">final</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> name</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">ActiveState</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Integer</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">code</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">String</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">name</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">code </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> code</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">name </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> name</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><p>如果账号已经处于“已失效”状态，这个时候收到账号修改信息的请求，我们可以直接丢弃消息拒绝处理。</p><p>在数据库层面，也可以对 SQL 做一些限制，例如：</p><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">-- 只有active_state=1才会执行</span></span>
<span class="line"><span style="color:#F78C6C;">update</span><span style="color:#A6ACCD;"> t </span><span style="color:#F78C6C;">set</span><span style="color:#A6ACCD;"> active_state</span><span style="color:#89DDFF;">=</span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">where</span><span style="color:#A6ACCD;"> id</span><span style="color:#89DDFF;">=</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">and</span><span style="color:#A6ACCD;"> active_state</span><span style="color:#89DDFF;">=</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"></span></code></pre></div><h3 id="_2-3-token-机制" tabindex="-1">2.3 token 机制 <a class="header-anchor" href="#_2-3-token-机制" aria-hidden="true">#</a></h3><p>在客户端执行某个操作时，先向服务端申请一个 token，服务端生成 token 并缓存；</p><p>客户端在发起操作请求时，带上这个 token；</p><p>服务端判断该 token 是否在缓存中，如果不在则认定该 token 已使用，将拒绝执行业务逻辑并返回提示；</p><p>如果服务端判断缓存中存在该 token，则认为该 token 未使用过，先移除缓存中的 token 再继续执行业务逻辑。</p><hr><p>欢迎加入本书作者的知识星球，在星球中您将获得：</p><ul><li>本书作者答疑，无论是DDD学习过程中的问题，还是对现有项目进行DDD重构，都可以找作者唠唠</li><li>获得本书配套源码以及多套完整的DDD项目实战源码，包括校招平台、直播平台，从此DDD概念不再抽象，就是抄也抄会了</li><li>DDD属于开发中的高阶知识，历来掌握者寥寥，研究DDD的同行职级都不低，这里是拓宽人脉的好地方</li><li>与即将推出的《TOGAF架构方法论》、《悟道项目管理》、《悟道团队管理》、《悟道产品经理》等书共用一个星球，同时可获得其他知识专题的答疑</li></ul><div><img src="https://s1.ax1x.com/2023/04/15/p9p2mKP.jpg"></div>`,34),o=[e];function t(c,r,C,i,y,D){return n(),a("div",null,o)}const d=s(p,[["render",t]]);export{F as __pageData,d as default};
