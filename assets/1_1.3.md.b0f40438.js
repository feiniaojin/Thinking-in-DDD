import{_ as D,c as d,o as e,a as i}from"./app.9803107f.js";const u=JSON.parse('{"title":"DDD 落地答疑","description":"","frontmatter":{},"headers":[{"level":2,"title":"1. DDD 适用范围","slug":"_1-ddd-适用范围","link":"#_1-ddd-适用范围","children":[]},{"level":2,"title":"2. 贫血模型与充血模型的选择","slug":"_2-贫血模型与充血模型的选择","link":"#_2-贫血模型与充血模型的选择","children":[]},{"level":2,"title":"3. DDD 落地的认知差异","slug":"_3-ddd-落地的认知差异","link":"#_3-ddd-落地的认知差异","children":[]},{"level":2,"title":"4. 落地 DDD 要选什么技术框架、要用什么架构","slug":"_4-落地-ddd-要选什么技术框架、要用什么架构","link":"#_4-落地-ddd-要选什么技术框架、要用什么架构","children":[]}],"relativePath":"1/1.3.md"}'),a={name:"1/1.3.md"},l=i('<h1 id="ddd-落地答疑" tabindex="-1">DDD 落地答疑 <a class="header-anchor" href="#ddd-落地答疑" aria-hidden="true">#</a></h1><h2 id="_1-ddd-适用范围" tabindex="-1">1. DDD 适用范围 <a class="header-anchor" href="#_1-ddd-适用范围" aria-hidden="true">#</a></h2><p>一直以来业界有这么一个论调：简单的系统不适合 DDD，复杂的系统才适合 DDD。那么，如何评价系统适不适合实施 DDD 呢，有什么量化的标准吗？</p><p>如果一套理论，在简单的场景实践表现不好，但是在复杂的场景实践比较很好，那么这套理论真的在复杂场景能表现好吗？我认为是不能的，复杂系统拆分之后也是由很多简单的子系统构成的，而且 DDD 也是系统拆分的利器。</p><p>之所以有“简单的系统不适合 DDD，复杂的系统才适合 DDD”的这么一个论调，完全不是因为 DDD 在简单的系统没办法实践，更多的是成本的考量。</p><p>主要有几方面成本：</p><ul><li>首先是学习成本，大部分团队成员缺乏 DDD 实战经验，需要花大力气进行培训；</li><li>其次是时间成本，一方面 DDD 倡导一个事务一次只更新一个聚合，为了保证跨聚合更新的一致性，需要投入大量的研发资源以解决技术细节问题，很有可能给项目正常交付造成风险；一方面在实践过程中缺乏提效工具；</li><li>最后，我们构建简单的系统时，往往是处在战略落地的初级阶段，团队整体缺乏领域专业知识，给领域驱动设计带来实践障碍。</li></ul><p>事实上，在业务落地的初期，我非常推荐采用事务脚本的方式进行面向数据的编程。事务脚本给了我们一次更新多个聚合的能力，使得我们开发非常快捷（虽然也很显得粗暴）。技术本身很难产生价值，技术往往需要通过业务载体产生价值，我们尽快把产品落地交付了，能让公司快速进行商业模式试错。</p><p>《实现领域驱动》这本书的第 1 章，介绍了一种 DDD 计分卡的方式，得分在 7 分以上，就推荐考虑实施 DDD。这种打分的方式有一定的依据，但是实际上我会通过更简单快捷的方式去判断我们是否适合实施 DDD。</p><p>我的判断方式是这样的：如果目标系统无法在一个数据库事务里进行跨聚合更新，那么就直接 DDD。DDD 要求一次数据库事务只能更新一个聚合，聚合之间要通过最终一致性保持一致。</p><p>当我们分库分表、某个业务服务切分到外部团队单独数据库存储时，我们没有办法保证在一个数据库事务里完成跨聚合的变更，那么就应该果断进行 DDD。 如果一开始就要分库分表，那一开始就实施 DDD。</p><h2 id="_2-贫血模型与充血模型的选择" tabindex="-1">2. 贫血模型与充血模型的选择 <a class="header-anchor" href="#_2-贫血模型与充血模型的选择" aria-hidden="true">#</a></h2><p>DDD 落地永远绕不开贫血模型和充血模型的争议。</p><p>关于贫血模型和充血模型的选择，我们将在<a href="./../2/2.2.html">2.2 贫血模型和充血模型</a>中进行详细论证。</p><p>完整的 DDD 落地是要求充血模型的，如果一个 DDD 落地选择了贫血模型，那么对 DDD 的落地是不完整的。</p><p>贫血模型最终会导致一个膨胀的 Service 层方法。 笔者推荐使用充血模型。</p><h2 id="_3-ddd-落地的认知差异" tabindex="-1">3. DDD 落地的认知差异 <a class="header-anchor" href="#_3-ddd-落地的认知差异" aria-hidden="true">#</a></h2><p>业界对于 DDD 的落地，主要有这么几种观点：</p><p>第一种，DDD 只有战略设计的落地。持这个观点的 DDD 实践者，主要是被 DDD 战术落地难的困境吓倒，他们找不到正确落地的完整实践，所以对 DDD 战术设计持悲观的态度。DDD 战略设计的落地无疑是非常有价值的，起码在大方向上完成了子域划分，但却舍弃了 DDD 大部分的精髓，他们并没有办法产出高质量的代码，因而他们很多号称落地 DDD 的项目，到最后又开倒车改成分层贫血架构。造成这个观点的原因，是因为 DDD 落地没有很好的案例、规范、配套研发提效工具，这也是笔者目前正在致力的方向：给案例、出规范、写工具。</p><p>第二种，只关注 DDD 部分战术落地。持这个观点的，大部分是一些 DDD 萌新朋友，由于对 DDD 理解的深度不够，经常纠结要选什么架构，经常纠结这个类、这个方法放哪里合适，束手束脚，举步维艰，最后也会放弃 DDD。</p><h2 id="_4-落地-ddd-要选什么技术框架、要用什么架构" tabindex="-1">4. 落地 DDD 要选什么技术框架、要用什么架构 <a class="header-anchor" href="#_4-落地-ddd-要选什么技术框架、要用什么架构" aria-hidden="true">#</a></h2><p>DDD 与技术框架无关，用什么开发语言、用什么技术框架都不影响 DDD 的落地。</p><p>DDD 常见的应用架构有很多：经典四层架构、六边形架构、整洁架构等等，很多刚接触 DDD 的朋友光是选择架构就挑花了眼。</p><p>DDD 学习成本高的一个原因，就是有很多 DDD 神棍（或者叫 DDD 骗子），搞了很多所谓的架构和框架，号称自己可以落地 DDD。学习者花费不少成本学习之后，才发现自己被欺骗了，进而对 DDD 持消极态度。</p><p>我们将会在第 2 章中专门讲 DDD 落地的应用架构。 本书的一个特点就是使用常见、通用的技术组件去实现 DDD，不把 DDD 落地与冷门偏门、学习成本高的组件进行捆绑销售。</p><p>本书案例的技术栈为：</p><ul><li>Spring Boot，Java 业界目前事实上的开发框架标准</li><li>Spring Data JDBC，用于 ORM</li><li>VUE，用于开发前端页面</li><li>MySQL，开源关系型数据库</li><li>Redis，开源 NoSQL 数据库，常用于缓存场景</li><li>Kafka，开源的消息队列</li></ul><hr><div><img src="https://s1.ax1x.com/2023/04/15/p9p2mKP.jpg"></div><p>欢迎加入本书作者的知识星球，在星球中您将获得：</p><ul><li>本书作者答疑，无论是DDD学习过程中的问题，还是对现有项目进行DDD重构，都可以一起探讨</li><li>获得本书配套源码以及多个完整的DDD项目实战源码，包括权限系统、电商系统、校招平台、直播平台等项目</li><li>DDD属于开发中的高阶知识，历来掌握者寥寥，研究DDD的同行职级都不低，这里是拓宽人脉的好地方</li><li>与即将推出的《TOGAF架构方法论》、《悟道项目管理》、《悟道团队管理》、《悟道产品经理》等书共用一个星球，一次加入即可同时可获得其他知识专题的答疑</li></ul>',31),p=[l];function r(t,_,h,n,s,c){return e(),d("div",null,p)}const f=D(a,[["render",r]]);export{u as __pageData,f as default};
